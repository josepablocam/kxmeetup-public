package orderly

import scala.io.Source

/**
 * Generates q code for orderly market orders. Constructs tables and performs upserts
 */
object CodeGenerator {
  def kdbSym(s: String): String = "`" + s
  def genValues(m: MarketOrder): String = {
    val side = m.side match {
      case Buy => kdbSym("buy")
      case Sell => kdbSym("sell")
    }
    val (volume, units) = m.volume match {
      case NumShares(n) => (n, kdbSym("shares"))
      case USDAmount(d) => (d, kdbSym("usd"))
    }
    val ticker = kdbSym(m.sym)
    val px = m.px.v
    val cond = m.when match {
      case Left(Verbatim(q)) => q
      case _ => throw new Exception("when conditions should be translated to q code for generation")
    }
    val client = kdbSym(m.client.getOrElse("self"))
    s"($side;$volume;$units;$ticker;$px;$cond;$client)"
  }

  def genUpsert(nm: String, ms: Seq[MarketOrder]): String = {
    val cols = List("side", "volume", "units", "ticker", "px", "cond", "client")
      .map(kdbSym)
      .mkString("")
    val values = ms.map(genValues) match {
      case x :: Nil => s"((),/:$x)"
      case ls @ x :: xs => s"flip (\n\t${ls.mkString(";\n\t")}\n\t)"
      case _ => throw new Exception("Empty insertion when generating code")
    }
   s"${kdbSym(nm)} upsert flip $cols!$values\n"
  }

  def genOrder(o: OrderInsert): String = o match {
    case BulkInsert(t, orders) => genUpsert(t, orders)
    case SingleInsert(t, order) => genUpsert(t, List(order))
  }

  def generate(prog: Seq[OrderInsert]) = {
    val include = Source.fromURL(
      getClass.getClassLoader.getResource("q/orderly_helpers.q")
    ).getLines().mkString("\n")
    val code = prog.map(genOrder).mkString("\n")
    "// automatically included\n" + include + "\n\n// generated by Orderly\n" + code
  }

  def apply(prog: Seq[OrderInsert]): String = generate(prog)
}
